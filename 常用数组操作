1、“+” 与 “array_merge”拼接数组区别
   “+”             不管key是数字、字符串，重复的键名只取第一次出现的，不改变键值。
   “array_merge”   key为数字：改键名。键从0开始重新赋值，key不会覆盖会累加。
                   key为字符串：不改变键名。重复的会覆盖前面的，取最后一个。
                   
2、array排序
  a：保持索引 ；  k：索引；  r：逆序排
sort — 对数组排序， 低到高，正序；不保持索引
rsort — 对数组排序， 高到低，逆序；不保持索引
ksort()--- 按照键名排序，正序；保持索引
krsort — 键名 逆序；保持索引关系
asort — 值正序；保持索引
arsort — 逆序；保持索引关系
usort — 使用用户自定义的比较函数对数组中的值进行排序，不保持
uasort — 使用用户自定义的比较函数对数组中的值进行排序，保持索引关联
uksort — 使用用户自定义的比较函数对数组中的键名进行排序，保持

3、array_multisort 对多个或多维数组排序。  类似于sql的order by 
列表排序、分页问题。
   需求：近期做的一个需求，要求对列表的某些状态分组排序，status=1,2,4&&replystatus=0的为“未回复”；status=1,2,4&&replystatus=1的为“已回复”；status=3的为“已关闭”。
要求未回复放前面，已回复放中间、已关闭放最后，10条一页。而且“未回复”“已回复”里有一部分特殊数据得挑出来排最前面。都按创建时间倒序排。
   思路：先用sql按时间倒序 查出两种数据“未回复+已回复”、“已关闭”（已排好序）,再处理“未回复+已回复”里的特殊数据。foreach循环出特殊数据放入specialArr中，
specialColumnArr排序列。然后用array_multisort（specialColumnArr，SORT_DESC,specialArr）排好序。最终拼成排好序的所有id的数组，进行逻辑分页。
   总结：遇到排序复杂的，不能用sql排序分页的。可以先查出所有的id，并排好序再逻辑分页。再用id去查列表相关信息
   

